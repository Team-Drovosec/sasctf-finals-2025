// AUTOGEN: pattern={{ pattern_name }} seed={{ seed }}
#include <stdint.h>
#include "ministd.h"
#include "trusted_lib_api.h"

static inline void init_buffers(uint8_t *buf_plain, uint8_t *iv, uint8_t *tag, uint32_t size) {
    for (uint32_t i = 0; i < size; ++i)
        buf_plain[i] = (uint8_t)(i & 0xFF);
    memset(iv, 0xA5, 12);
    memset(tag, 0, 16);
    memxor(buf_plain, iv, (12 < size) ? 12 : size);
}

static inline void create_plain_files_symbolic(uint8_t *buf_plain, uint64_t *handles,
                                               uint32_t file_size, int count,
                                               const char *fmt_handle, uint64_t *acc) {
#pragma unroll
    for (int i = 0; i < count; ++i) {
        uint64_t h = TRUSTED_CALL(create_file_plain, buf_plain, file_size);
        handles[i] = h;
        *acc += h;

        if (h & 1ULL) {
            TRUSTED_CALL_VOID(mini_printf, fmt_handle, h);
        } else {
            uint64_t h2 = TRUSTED_CALL(create_file_enc, buf_plain, file_size, (uint32_t*)buf_plain, (uint32_t*)buf_plain);
            *acc += h2;
        }
    }
}

static inline void read_plain_files(uint64_t *handles, uint32_t file_size,
                                    int count, const char *fmt_ret,
                                    uint64_t *acc_r, uint64_t *acc_l) {
#pragma unroll
    for (int p = 0; p < count; ++p) {
        uint8_t outbuf[{{ FILE_SIZE }} + 4];
        uint32_t outlen = file_size;
        int32_t r = TRUSTED_CALL(read_file_plain, handles[p], outbuf, &outlen);

        *acc_r += (uint64_t)r;
        *acc_l += (uint64_t)outlen;

        if (r > 0) {
            outbuf[p % sizeof(outbuf)] ^= (uint8_t)(r & 0xFF);
        } else {
            outbuf[(p + 1) % sizeof(outbuf)] ^= (uint8_t)((~r) & 0xFF);
        }
    }
}

static inline uint32_t postprocess(uint8_t *iv, uint8_t *tag) {
    uint8_t tmp[32] = { 0 };
    size_t copy_len = (sizeof(tmp) < 12) ? sizeof(tmp) : 12;
    memcpy(tmp, iv, copy_len);
    size_t xor_len = (sizeof(tag) < sizeof(tmp)) ? sizeof(tag) : sizeof(tmp);
    memxor(tmp, tag, xor_len);
    uint32_t sum = 0;
    for (size_t i = 0; i < sizeof(tmp); ++i)
        sum += tmp[i];
    return sum;
}

ENTRY_POINT_ATTR void start(void) {
    uint8_t buf_plain[{{ FILE_SIZE }}];
    uint8_t iv[12];
    uint8_t tag[16];
    uint64_t handles_plain[{{ COUNT_PLAIN }}];

{% if FORMAT_CASE == 0 %}
    char fmt_handle[5] = {'%','l','l','x',0};
    char fmt_ret[3] = {'%','d',0};
{% else %}
    char fmt_handle[3] = {'%','d',0};
    char fmt_ret[5] = {'%','l','l','x',0};
{% endif %}

    uint64_t acc_h = 0, acc_r = 0, acc_l = 0;

    init_buffers(buf_plain, iv, tag, {{ FILE_SIZE }});

    create_plain_files_symbolic(buf_plain, handles_plain, {{ FILE_SIZE }},
                                {{ COUNT_PLAIN }}, fmt_handle, &acc_h);

    read_plain_files(handles_plain, {{ FILE_SIZE }}, {{ COUNT_PLAIN }},
                     fmt_ret, &acc_r, &acc_l);

    uint32_t sum = postprocess(iv, tag);

    TRUSTED_CALL_VOID(mini_printf, fmt_ret, acc_h);
    TRUSTED_CALL_VOID(mini_printf, fmt_ret, acc_r);
    TRUSTED_CALL_VOID(mini_printf, fmt_ret, (uint64_t)sum);

    ENTRY_POINT_END();
}
