from collections import Counter
from functools import reduce
from typing import Dict, List

import z3
from crack.cipher.constants import F_D_INDEXES
from crack.cipher.core import LSFR_c, LSFR_d, Register
from crack.cipher.utils import add_vectors_mod_2, iv_89_to_10

################################
# CONSTANTS AND CLASSES
init_c_to_v12_v20 = {1: (0, 0), 2: (0, 1), 3: (1, 0), 4: (1, 1)}
v12_v20_to_c = {(0, 0): 1, (0, 1): 2, (1, 0): 3, (1, 1): 4}


class LSFR_d_literals(Register):
    def __init__(self, state_literals):
        if len(state_literals) != 89:
            raise ValueError(f"len state_literals not 89, is {len(state_literals)}")
        self.state = state_literals

    def feedback(self):
        # u[89+t] = u[88+t] + u[50+t] + u[47+t] + u[36+t] + u[34+t] + u[9+t] + u[6+t] + u[t]
        return '+'.join([self.state[88], self.state[50], self.state[47]
               , self.state[36], self.state[34], self.state[9]
               , self.state[6], self.state[0]])

    def shift_left(self):
        self.state = self.state[1:] + [0]    
    
    def clock(self, c: int):
        for _ in range(c):
            new_bit = self.feedback()
            self.shift_left()
            self.state[-1] = new_bit
    
    def get_state(self):
        return self.state

    def get_10_input_bits(self):
        return [self.state[ind] for ind in F_D_INDEXES]


class TableForSecondPhase:
    def __init__(self, pairs_iv_kstream, sk_39, cnt_tacts):
        self.tact_to_IVs_indexes = dict()
        # el: dict: tact -> IV state
        self.list_IVs = []
        self.tact_to_IVs_indexes_grouped = dict()
    
        for pair in pairs_iv_kstream:
            iv, key_stream = pair
            self.list_IVs.append(self.iv_to_raw(iv, sk_39, cnt_tacts))
        
        # +5 for convinient
        for tact in range(cnt_tacts*4+5):
            for i in range(len(self.list_IVs)):
                if tact in self.list_IVs[i]:
                    if tact not in self.tact_to_IVs_indexes:
                        self.tact_to_IVs_indexes[tact] = []
                    self.tact_to_IVs_indexes[tact].append(i)

    
    def get_list_IVs(self):
        return self.list_IVs
    
    def get_tact_to_IVs_indexes(self):
        return self.tact_to_IVs_indexes

    def get_tact_to_IVs_indexes_grouped(self):
        return self.tact_to_IVs_indexes_grouped
    
    def iv_to_raw(self, iv_128, sk_39, cnt_tacts):
        raw = dict()
        iv39_oplus_sk39_state = add_vectors_mod_2(iv_128[:39], sk_39)
        iv89_state = iv_128[39:]
        for t in range(cnt_tacts):
            lsfr_c = LSFR_c()
            lsfr_c.load_state(iv39_oplus_sk39_state)
            lsfr_d = LSFR_d()
            lsfr_d.load_state(iv89_state)
            res_c = 0
            for _ in range(t+1):
                c = lsfr_c.clock()
                _ = lsfr_d.clock(c)
                res_c += c
            raw[res_c] = iv_89_to_10(lsfr_d.get_state())
        return raw

################################

################################
# HELPER FUNCTIONS
def nary_xor(bits):
    return reduce(lambda a, b: z3.Xor(a, b), bits)

def solve_gf2_z3(equations: List[str]) -> Dict[str, int]:
    vars_z3: Dict[str, z3.BoolRef] = {}
    constraints = []

    for eq in equations:
        try:
            lhs, rhs_str = eq.split('=')
        except ValueError:
            raise ValueError(f'Incorrect equation format: {eq!r}')

        rhs = rhs_str.strip()
        if rhs not in ('0', '1'):
            raise ValueError(f'Right part should be either 0 or 1: {eq!r}')
        rhs_bool = rhs == '1'

        tokens = [t.strip() for t in lhs.split('+') if t.strip()]
        if not tokens:
            raise ValueError(f'Left part is empty: {eq!r}')

        tokens = [v for v, c in Counter(tokens).items() if c % 2 == 1]
        if not tokens:
            if rhs_bool:
                raise ValueError('Unsat')
            continue

        for v in tokens:
            vars_z3.setdefault(v, z3.Bool(v))

        if len(tokens) == 1:
            constraints.append(vars_z3[tokens[0]] == rhs_bool)
        else:
            xor_expr = nary_xor(vars_z3[v] for v in tokens)
            constraints.append(xor_expr == rhs_bool)

    s = z3.Solver()
    s.add(constraints)

    if s.check() != z3.sat:
        raise ValueError('Unsat')

    model = s.model()
    return {v: int(bool(model.evaluate(b, model_completion=True))) for v, b in vars_z3.items()}

def shift_89(iv_89, iter):
    if iter == 0:
        return iv_89
    for _ in range(iter):
        new = (iv_89[88] + iv_89[50] + iv_89[47]
                + iv_89[36] + iv_89[34] + iv_89[9]
                + iv_89[6] + iv_89[0]) % 2
        iv_89 =  iv_89[1:] + [0]
        iv_89[-1] = new
    return iv_89

def iv_89_to_10(iv_89):
    res = []
    for ind in F_D_INDEXES:
        res.append(iv_89[ind])
    return res

def shift_39(iv_39, iter):
    if iter == 0:
        return iv_39
    for _ in range(iter):
        new = (iv_39[37] + iv_39[25] + iv_39[24]
                + iv_39[22] + iv_39[8] + iv_39[6]
                + iv_39[4] + iv_39[0]) % 2
        iv_39 =  iv_39[1:] + [0]
        iv_39[-1] = new
    return iv_39

def shift_text(sk):
    new = f"{sk[37]}+{sk[25]}+{sk[24]}+{sk[22]}+{sk[8]}+{sk[6]}+{sk[4]}+{sk[0]}"
    sk =  sk[1:] + ["0"]
    sk[-1] = new
    return sk 

def my_max(array):
    res = None
    for el in array:
        if el != None:
            if res != None:
                res = max(res, el)
            else:
                res = el
    return res

def vec_to_zeroes(vec):
    res = [0] * 89
    for i, ind in enumerate(F_D_INDEXES):
        res[ind] = vec[i]
    return res

################################

# test
if __name__ == "__main__":
    equations = ['x_37+x_25+x_24+x_22+x_8+x_6+x_4+x_0=1', 'x_38+x_26+x_25+x_23+x_9+x_7+x_5+x_1=1', 'x_37+x_25+x_24+x_22+x_8+x_6+x_4+x_0+x_27+x_26+x_24+x_10+x_8+x_6+x_2=1', 'x_38+x_26+x_25+x_23+x_9+x_7+x_5+x_1+x_28+x_27+x_25+x_11+x_9+x_7+x_3=0', 'x_37+x_25+x_24+x_22+x_8+x_6+x_4+x_0+x_27+x_26+x_24+x_10+x_8+x_6+x_2+x_29+x_28+x_26+x_12+x_10+x_8+x_4=0', 'x_38+x_26+x_25+x_23+x_9+x_7+x_5+x_1+x_28+x_27+x_25+x_11+x_9+x_7+x_3+x_30+x_29+x_27+x_13+x_11+x_9+x_5=1', 'x_37+x_25+x_24+x_22+x_8+x_6+x_4+x_0+x_27+x_26+x_24+x_10+x_8+x_6+x_2+x_29+x_28+x_26+x_12+x_10+x_8+x_4+x_31+x_30+x_28+x_14+x_12+x_10+x_6=0', 'x_38+x_26+x_25+x_23+x_9+x_7+x_5+x_1+x_28+x_27+x_25+x_11+x_9+x_7+x_3+x_30+x_29+x_27+x_13+x_11+x_9+x_5+x_32+x_31+x_29+x_15+x_13+x_11+x_7=0', 'x_37+x_25+x_24+x_22+x_8+x_6+x_4+x_0=1', 'x_37+x_25+x_24+x_22+x_8+x_6+x_4+x_0+x_27+x_26+x_24+x_10+x_8+x_6+x_2+x_29+x_28+x_26+x_12+x_10+x_8+x_4+x_31+x_30+x_28+x_14+x_12+x_10+x_6+x_33+x_32+x_30+x_16+x_14+x_12+x_8=0', 'x_38+x_26+x_25+x_23+x_9+x_7+x_5+x_1=1', 'x_38+x_26+x_25+x_23+x_9+x_7+x_5+x_1+x_28+x_27+x_25+x_11+x_9+x_7+x_3+x_30+x_29+x_27+x_13+x_11+x_9+x_5+x_32+x_31+x_29+x_15+x_13+x_11+x_7+x_34+x_33+x_31+x_17+x_15+x_13+x_9=0', 'x_37+x_25+x_24+x_22+x_8+x_6+x_4+x_0+x_27+x_26+x_24+x_10+x_8+x_6+x_2=1', 'x_37+x_25+x_24+x_22+x_8+x_6+x_4+x_0+x_27+x_26+x_24+x_10+x_8+x_6+x_2+x_29+x_28+x_26+x_12+x_10+x_8+x_4+x_31+x_30+x_28+x_14+x_12+x_10+x_6+x_33+x_32+x_30+x_16+x_14+x_12+x_8+x_35+x_34+x_32+x_18+x_16+x_14+x_10=0', 'x_38+x_26+x_25+x_23+x_9+x_7+x_5+x_1+x_28+x_27+x_25+x_11+x_9+x_7+x_3=0', 'x_38+x_26+x_25+x_23+x_9+x_7+x_5+x_1+x_28+x_27+x_25+x_11+x_9+x_7+x_3+x_30+x_29+x_27+x_13+x_11+x_9+x_5+x_32+x_31+x_29+x_15+x_13+x_11+x_7+x_34+x_33+x_31+x_17+x_15+x_13+x_9+x_36+x_35+x_33+x_19+x_17+x_15+x_11=0', 'x_37+x_25+x_24+x_22+x_8+x_6+x_4+x_0+x_27+x_26+x_24+x_10+x_8+x_6+x_2+x_29+x_28+x_26+x_12+x_10+x_8+x_4=0', 'x_37+x_25+x_24+x_22+x_8+x_6+x_4+x_0+x_27+x_26+x_24+x_10+x_8+x_6+x_2+x_29+x_28+x_26+x_12+x_10+x_8+x_4+x_31+x_30+x_28+x_14+x_12+x_10+x_6+x_33+x_32+x_30+x_16+x_14+x_12+x_8+x_35+x_34+x_32+x_18+x_16+x_14+x_10+x_37+x_36+x_34+x_20+x_18+x_16+x_12=0', 'x_38+x_26+x_25+x_23+x_9+x_7+x_5+x_1+x_28+x_27+x_25+x_11+x_9+x_7+x_3+x_30+x_29+x_27+x_13+x_11+x_9+x_5=1', 'x_38+x_26+x_25+x_23+x_9+x_7+x_5+x_1+x_28+x_27+x_25+x_11+x_9+x_7+x_3+x_30+x_29+x_27+x_13+x_11+x_9+x_5+x_32+x_31+x_29+x_15+x_13+x_11+x_7+x_34+x_33+x_31+x_17+x_15+x_13+x_9+x_36+x_35+x_33+x_19+x_17+x_15+x_11+x_38+x_37+x_35+x_21+x_19+x_17+x_13=0', 'x_12=1', 'x_13=1', 'x_14=0', 'x_15=1', 'x_16=0', 'x_17=1', 'x_18=1', 'x_19=0', 'x_20=0', 'x_21=0', 'x_22=1', 'x_23=0', 'x_24=0', 'x_25=1', 'x_26=0', 'x_27=1', 'x_28=0', 'x_29=0', 'x_30=0', 'x_31=0', 'x_32=1', 'x_33=0', 'x_34=1', 'x_35=1', 'x_36=1', 'x_37=0', 'x_38=1']
    print(len(equations))
    sol = solve_gf2_z3(equations)
    for name, val in sorted(sol.items(), key=lambda t: int(t[0].split('_')[1])):
        print(f'{name} = {val}')