#!/usr/bin/env python3

import base64
import json
import os
import threading
import time
from urllib.parse import urljoin

import requests  # type: ignore
import websocket  # type: ignore
from crack.cipher.constants import F_D_INDEXES  # type: ignore
from crack.cipher.core import LSFR_d, StreamCipher  # type: ignore
from crack.cipher.utils import add_vectors_mod_2  # type: ignore
from crack.helpers import (LSFR_d_literals, TableForSecondPhase,
                           init_c_to_v12_v20, iv_89_to_10, my_max, shift_39,
                           shift_89, shift_text, solve_gf2_z3, v12_v20_to_c,
                           vec_to_zeroes)

KEYSTREAM_LENGTH = 130


HOST = 'http://localhost:4000'
GAME_ID = 'XLKCRVDOTISRHCSGNHO543VDBS'
PAIRS_PHASE1 = 320
PAIRS_PHASE2 = 200
MSG_BYTES = 16

def ws_url(base, path):
    if base.startswith('https://'):
        return 'wss://' + base[len('https://'):] + path
    if base.startswith('http://'):
        return 'ws://' + base[len('http://'):] + path
    raise ValueError('base must start with http:// or https://')


def b64_to_bits(b64: str):
    raw = base64.b64decode(b64)
    bits = []
    for b in raw:
        for i in range(7, -1, -1):
            bits.append((b >> i) & 1)
    return bits


def collect_pairs(base, game_id, session: requests.Session, want_pairs: int, msg_bytes: int):
    url = ws_url(base, f"/chat?id={game_id}")
    pairs = []
    history = []
    stop = threading.Event()
    my_user = None

    def on_message(ws, message):
        try:
            msg = json.loads(message)
        except Exception:
            return
        history.append(msg)
        nonlocal my_user
        if msg.get('is_private') and isinstance(msg.get('iv'), list) and len(msg['iv']) == 128 and msg.get('Content'):
            try:
                raw = base64.b64decode(msg['Content'])
            except Exception:
                raw = b''
            if len(raw) != msg_bytes:
                return
            if my_user is None:
                my_user = msg.get('user')
            if msg.get('user') != my_user:
                return
            pairs.append((msg['iv'], msg['Content']))
            if len(pairs) >= want_pairs:
                stop.set()

    def on_error(ws, err):
        stop.set()

    def on_close(ws, code, reason):
        stop.set()

    cookies = session.cookies.get_dict()
    cookie_header = '; '.join([f"{k}={v}" for k, v in cookies.items()])
    ws = websocket.WebSocketApp(
        url,
        header=[f"Cookie: {cookie_header}"],
        on_message=on_message,
        on_error=on_error,
        on_close=on_close,
    )

    th = threading.Thread(target=ws.run_forever, kwargs={'ping_timeout': 20})
    th.daemon = True
    th.start()

    # actively trigger private messages
    chosen_msg = 'A' * msg_bytes
    for i in range(want_pairs + 50):
        try:
            session.post(urljoin(base, '/private-chat'), json={"game": game_id, "message": chosen_msg}, timeout=5)
        except Exception:
            pass
        if stop.is_set():
            break
        time.sleep(0.01)

    # wait a bit for remaining messages
    t0 = time.time()
    while time.time() - t0 < 3 and len(pairs) < want_pairs:
        if stop.is_set():
            break
        time.sleep(0.05)

    try:
        ws.close()
    except Exception:
        pass

    return pairs, history, my_user


def get_recent_game_id(base, session: requests.Session):
    r = session.get(urljoin(base, '/recent-games'), timeout=5)
    r.raise_for_status()
    games = r.json()
    if not games:
        raise RuntimeError('no recent games for this session')
    return games[0]['ID']


def str_to_bits(s: str):
    bits = []
    for b in s.encode('utf-8', errors='ignore'):
        for i in range(7, -1, -1):
            bits.append((b >> i) & 1)
    return bits


def bits_to_bytes(bits):
    if len(bits) % 8 != 0:
        bits = bits[: len(bits) - (len(bits) % 8)]
    out = bytearray(len(bits) // 8)
    for i in range(len(out)):
        val = 0
        for j in range(8):
            val = (val << 1) | (bits[i * 8 + j] & 1)
        out[i] = val
    return bytes(out)


def create_table_r_t(pairs_iv_kstream):
    table = [None for _ in range(len(pairs_iv_kstream))]
    for i in range(len(pairs_iv_kstream)):
        table[i] = [None] * (KEYSTREAM_LENGTH + 1)
    for t in range(0, KEYSTREAM_LENGTH + 1):
        for i, pair in enumerate(pairs_iv_kstream):
            iv, key_stream = pair
            iv_89 = iv[39:]
            table[i][t] = iv_89_to_10(shift_89(iv_89.copy(), t))
    return table


def phase_1_collected(pairs_iv_kstream):
    cracked_bits = [None] * 39
    equations = []
    table_r_t = create_table_r_t(pairs_iv_kstream)
    c_flags = [True, True, True, True]

    for init_c in [1, 2, 3, 4]:
        iter_idx = 1
        secret_key_39 = [f"x_{i}" for i in range(39)]
        true_shift_iv_core = [0] * len(pairs_iv_kstream)
        for _ in range(33):
            cnt_for_c = [0, 0, 0, 0]
            if not c_flags[init_c - 1]:
                break
            if iter_idx == 1:
                generated = []
                for p, pair in enumerate(pairs_iv_kstream):
                    iv, key_stream = pair
                    iv_iter = iv[:39]
                    v_12, v_20 = init_c_to_v12_v20[init_c]
                    t_c = 2 * ((iv_iter[12] + v_12) % 2) + ((iv_iter[20] + v_20) % 2) + 1
                    true_shift_iv_core[p] += t_c
                    generated.append((table_r_t[p][true_shift_iv_core[p]], true_shift_iv_core[p], key_stream))
                from itertools import combinations
                for a, b in combinations(generated, 2):
                    v_it, t_i, key_stream_i = a
                    v_jt, t_j, key_stream_j = b
                    if v_it == v_jt and (t_i == t_j):
                        if key_stream_i[iter_idx] == key_stream_j[iter_idx]:
                            cnt_for_c[init_c - 1] += 1
                        else:
                            c_flags[init_c - 1] = False
                            cnt_for_c[init_c - 1] = None
                            break
                v_12, v_20 = init_c_to_v12_v20[c_flags.index(True) + 1]
                cracked_bits[12] = v_12
                cracked_bits[20] = v_20
                secret_key_39 = shift_text(secret_key_39)
            else:
                v_flags = [True, True, True, True]
                for v_12, v_20 in ((0, 0), (0, 1), (1, 0), (1, 1)):
                    true_shift_iv_tmp = [0] * len(pairs_iv_kstream)
                    if v_flags[v12_v20_to_c[(v_12, v_20)] - 1]:
                        generated = []
                        for p, pair in enumerate(pairs_iv_kstream):
                            iv, key_stream = pair
                            iv_iter = shift_39(iv[:39].copy(), iter_idx - 1)
                            t_c = 2 * ((iv_iter[12] + v_12) % 2) + ((iv_iter[20] + v_20) % 2) + 1
                            true_shift_iv_tmp[p] = true_shift_iv_core[p] + t_c
                            generated.append((table_r_t[p][true_shift_iv_tmp[p]], true_shift_iv_tmp[p], p, key_stream))
                        from itertools import combinations
                        for a, b in combinations(generated, 2):
                            v_it, t_i, ind_i, key_stream_i = a
                            v_jt, t_j, ind_j, key_stream_j = b
                            if v_it == v_jt and (t_i == t_j) and (ind_i != ind_j):
                                if key_stream_i[iter_idx] == key_stream_j[iter_idx]:
                                    cnt_for_c[v12_v20_to_c[(v_12, v_20)] - 1] += 1
                                else:
                                    v_flags[v12_v20_to_c[(v_12, v_20)] - 1] = False
                                    cnt_for_c[v12_v20_to_c[(v_12, v_20)] - 1] = None
                                    break
                index = cnt_for_c.index(my_max(cnt_for_c))
                if v_flags[index]:
                    v_12, v_20 = init_c_to_v12_v20[index + 1]
                    for p, pair in enumerate(pairs_iv_kstream):
                        iv, key_stream = pair
                        iv_iter = shift_39(iv[:39].copy(), iter_idx - 1)
                        t_c = 2 * ((iv_iter[12] + v_12) % 2) + ((iv_iter[20] + v_20) % 2) + 1
                        true_shift_iv_core[p] = true_shift_iv_core[p] + t_c
                    if iter_idx < 20:
                        cracked_bits[12 + iter_idx - 1] = v_12
                        cracked_bits[20 + iter_idx - 1] = v_20
                    else:
                        if '+' in secret_key_39[12]:
                            equations.append(secret_key_39[12] + f"={v_12}")
                        if '+' in secret_key_39[20]:
                            equations.append(secret_key_39[20] + f"={v_20}")
                secret_key_39 = shift_text(secret_key_39)
            iter_idx += 1
        if c_flags[init_c - 1]:
            for i, val in enumerate(cracked_bits):
                if val is not None:
                    equations.append(f"x_{i}={val}")
    sol = solve_gf2_z3(equations)
    cracked_bits_full = []
    for name, val in sorted(sol.items(), key=lambda t: int(t[0].split('_')[1])):
        cracked_bits_full.append(val)
    return cracked_bits_full


def phase_2_collected(pairs_iv_kstream, secret_key_cracked_39):
    lsfr_d = LSFR_d()

    k_0 = {vec: 0 for vec in __import__('itertools').product([0, 1], repeat=10)}
    for iv, key_stream in pairs_iv_kstream:
        iv_89 = iv[39:]
        for vec in list(k_0.keys()):
            vec_to_zeroes_89 = vec_to_zeroes(vec)
            lsfr_d.load_state(add_vectors_mod_2(vec_to_zeroes_89, iv_89))
            output_bit = lsfr_d.clock(0)
            if key_stream[0] == output_bit:
                k_0[vec] += 1
    candidats = sorted([(el[1], el[0]) for el in k_0.items()], reverse=True)
    cnt, k_0_vec = candidats[0]
    if cnt <= 0:
        raise RuntimeError('failed to derive first 10 bits')
    cracked_bits_full = []
    for i, ind in enumerate(F_D_INDEXES):
        cracked_bits_full.append((ind, k_0_vec[i]))

    secret_key_literals = [f'x_{i}' for i in range(0, 89)]
    for i, ind in enumerate(F_D_INDEXES):
        secret_key_literals[ind] = str(k_0_vec[i])
    lsfr_d_literals = LSFR_d_literals(secret_key_literals)

    table = TableForSecondPhase(pairs_iv_kstream, secret_key_cracked_39, 10)
    list_IVs = table.get_list_IVs()
    tact_to_IVs_indexes = table.get_tact_to_IVs_indexes()
    all_tacts = sorted(tact_to_IVs_indexes.keys())

    k_t_list = [vec for vec in __import__('itertools').product([0, 1], repeat=10)]
    equations = []
    for tact_d in all_tacts[:20]:
        for k_t in k_t_list:
            is_found = True
            for i, iv_number in enumerate(tact_to_IVs_indexes[tact_d]):
                iv_state = list_IVs[iv_number][tact_d]
                tact_c = sorted(list_IVs[iv_number].keys()).index(tact_d) + 1
                k_t_to_zeroes_89 = vec_to_zeroes(k_t)
                iv_state_to_zeroes_89 = vec_to_zeroes(iv_state)
                lsfr_d.load_state(add_vectors_mod_2(k_t_to_zeroes_89, iv_state_to_zeroes_89))
                output_bit = lsfr_d.clock(0)
                key_stream = pairs_iv_kstream[iv_number][1]
                key_stream_bit = key_stream[tact_c]
                if output_bit != key_stream_bit:
                    is_found = False
                    break
            if is_found:
                lsfr_d_literals = LSFR_d_literals(secret_key_literals)
                lsfr_d_literals.clock(tact_d)
                for left, right in zip(lsfr_d_literals.get_10_input_bits(), k_t):
                    equations.append(f"{left}={right}")
                break
    sol = solve_gf2_z3(equations)
    for el in sol.items():
        if "x" in el[0]:
            number_value = int(el[0].split('_')[1])
            cracked_bits_full.append((number_value, el[1]))
    cracked_bits_full.sort()
    assert len(cracked_bits_full) == 89
    return [el[1] for el in cracked_bits_full]


def recover_key_from_pairs(pairs, msg_bytes):
    plaintext = 'A' * msg_bytes
    p_bits = str_to_bits(plaintext)
    pairs_iv_k = []
    for iv, b64 in pairs:
        c_bits = b64_to_bits(b64)
        if len(c_bits) < KEYSTREAM_LENGTH:
            continue
        ks = [(c_bits[i] ^ p_bits[i]) for i in range(KEYSTREAM_LENGTH)]
        pairs_iv_k.append((iv, ks))
    if len(pairs_iv_k) < 50:
        raise RuntimeError('not enough usable pairs for cracking')
    sk39 = phase_1_collected(pairs_iv_k)
    sk89 = phase_2_collected(pairs_iv_k, sk39)
    return sk39 + sk89


def decrypt_history(history, secret_key_bits, attacker_user=None):
    cipher = StreamCipher(secret_key_bits)
    out = []
    for msg in history:
        user = msg.get('user')
        # Skip messages sent by the attacker
        if attacker_user is not None and user == attacker_user:
            continue
        if not msg.get('is_private'):
            out.append((user, False, msg.get('Content')))
            continue
        iv = msg.get('iv')
        b64 = msg.get('Content')
        if not isinstance(iv, list) or len(iv) != 128 or not b64:
            continue
        c_bits = b64_to_bits(b64)
        p_bits, _ = cipher.crypt(plaintext=c_bits, IV=iv)
        try:
            text = bits_to_bytes(p_bits).decode('utf-8', errors='replace')
        except Exception:
            text = ''
        out.append((user, True, text))
    return out


def main():
    session = requests.Session()

    game_id = GAME_ID or get_recent_game_id(HOST, session)

    # ensure keystream length matches collected ciphertext bit length
    global KEYSTREAM_LENGTH
    KEYSTREAM_LENGTH = min(KEYSTREAM_LENGTH, MSG_BYTES * 8)

    want = PAIRS_PHASE1 + PAIRS_PHASE2
    pairs, history, attacker_user = collect_pairs(HOST, game_id, session, want, MSG_BYTES)
    print(f"collected pairs: {len(pairs)}")

    try:
        secret_key_bits = recover_key_from_pairs(pairs, MSG_BYTES)
        print(f"key recovered: {''.join(map(str, secret_key_bits))}")
        decrypted = decrypt_history(history, secret_key_bits, attacker_user=attacker_user)
        for user, is_priv, content in decrypted:
            tag = 'priv' if is_priv else 'pub'
            print(f"[{tag}] {user}: {content}")
    except Exception as e:
        print('crack/decrypt failed:', e)


if __name__ == '__main__':
    os.environ.setdefault('WEBSOCKET_CLIENT_CA_BUNDLE', '')
    websocket.setdefaulttimeout(20)
    main()
