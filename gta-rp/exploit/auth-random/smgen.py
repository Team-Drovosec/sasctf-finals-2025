# https://hackage-content.haskell.org/package/splitmix-0.1.1/docs/src/System.Random.SplitMix.html#SMGen


def u64(x):
    return x & 0xFFFFFFFFFFFFFFFF


def plus(a, b):
    return u64(a + b)


def shift_xor(n, w):
    return w ^ (w >> n)


def shift_xor_multiply(n, k, w):
    return u64(shift_xor(n, w) * k)


def popcount(x):
    return bin(x).count("1")


GOLDEN_GAMMA = 0x9E3779B97F4A7C15


def mix64(z):
    z1 = shift_xor_multiply(33, 0xFF51AFD7ED558CCD, z)
    z2 = shift_xor_multiply(33, 0xC4CEB9FE1A85EC53, z1)
    z3 = shift_xor(33, z2)
    return u64(z3)


def mix64variant13(z):
    z1 = shift_xor_multiply(30, 0xBF58476D1CE4E5B9, z)
    z2 = shift_xor_multiply(27, 0x94D049BB133111EB, z1)
    z3 = shift_xor(31, z2)
    return u64(z3)


def mix_gamma(z):
    z1 = mix64variant13(z) | 1  # force to be odd
    n = popcount(z1 ^ (z1 >> 1))
    if n >= 24:
        return z1
    else:
        return z1 ^ 0xAAAAAAAAAAAAAAAA


class SMGen:
    def __init__(self, seed, gamma):
        self.seed = u64(seed)
        self.gamma = u64(gamma)

    @staticmethod
    def mkSMGen(s):
        seed = mix64(s)
        gamma = mix_gamma(plus(s, GOLDEN_GAMMA))
        return SMGen(seed, gamma)

    def next_word64(self):
        seed_prime = plus(self.seed, self.gamma)
        result = mix64(seed_prime)
        return result, SMGen(seed_prime, self.gamma)

    def split(self):
        seed_prime = plus(self.seed, self.gamma)
        seed_double_prime = plus(seed_prime, self.gamma)
        return (
            SMGen(seed_double_prime, self.gamma),
            SMGen(mix64(seed_prime), mix_gamma(seed_double_prime)),
        )
