from z3 import BitVec, LShR, Extract, BitVecVal, Solver
import z3


def get_seed(a, b):
    # Helpers
    def u64(x):
        return x & 0xFFFFFFFFFFFFFFFF

    def plus(a, b):
        return a + b

    def shift_xor(n, w):
        return w ^ LShR(w, n)

    def shift_xor_multiply(n, k, w):
        return shift_xor(n, w) * BitVecVal(k, 64)

    def popcount(x):
        bits = [Extract(i, i, x) for i in range(64)]
        return sum(bits)

    GOLDEN_GAMMA = BitVecVal(0x9E3779B97F4A7C15, 64)

    def mix64(z):
        z1 = shift_xor_multiply(33, 0xFF51AFD7ED558CCD, z)
        z2 = shift_xor_multiply(33, 0xC4CEB9FE1A85EC53, z1)
        z3 = shift_xor(33, z2)
        return z3

    def mix64variant13(z):
        z1 = shift_xor_multiply(30, 0xBF58476D1CE4E5B9, z)
        z2 = shift_xor_multiply(27, 0x94D049BB133111EB, z1)
        z3 = shift_xor(31, z2)
        return z3

    def mix_gamma(z):
        z1 = mix64variant13(z) | BitVecVal(1, 64)
        n = popcount(z1 ^ LShR(z1, 1))
        cond = n >= 24
        return z3.If(cond, z1, z1 ^ BitVecVal(0xAAAAAAAAAAAAAAAA, 64))

    class SMGen:
        def __init__(self, seed, gamma):
            self.seed = seed
            self.gamma = gamma

        @staticmethod
        def mkSMGen(s):
            seed = mix64(s)
            gamma = mix_gamma(s + GOLDEN_GAMMA)
            return SMGen(seed, gamma)

        def next_word64(self):
            seed_prime = self.seed + self.gamma
            result = mix64(seed_prime)
            return result, SMGen(seed_prime, self.gamma)

        def split(self):
            seed_prime = self.seed + self.gamma
            seed_double_prime = seed_prime + self.gamma
            return (
                SMGen(seed_double_prime, self.gamma),
                SMGen(mix64(seed_prime), mix_gamma(seed_double_prime)),
            )

    s = z3.BitVec("s", 64)
    g = z3.BitVec("g", 64)
    rng = SMGen(s, g)
    a_s, rng1 = rng.next_word64()
    b_s, rng2 = rng1.next_word64()
    solver = z3.Solver()
    solver.add(a_s == BitVecVal(a, 64))
    solver.add(b_s == BitVecVal(b, 64))
    assert solver.check() == z3.sat
    model = solver.model()
    return model.eval(s).py_value(), model.eval(g).py_value()


if __name__ == "__main__":
    print(get_seed(2572389730006069381, 11952305761918001559))
